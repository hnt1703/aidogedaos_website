// Add following Javascript Sources to html:
// <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/ScrollTrigger.min.js"></script>
// <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/Draggable.min.js"></script>
// <script src="https://cdn.jsdelivr.net/npm/split-type@0.3.4/umd/index.min.js"></script>
// <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script> 

// Add CSS:
// [data-gsap] { opacity: 0; } html.w-editor [data-gsap] { opacity: 1; } /* .word { overflow: hidden; padding-bottom: 0.1em; margin-bottom: -0.1em; transform-origin: bottom; } */

//
// This file was generated by Slater.app - tonik-gsap-pro.js 



var Webflow = Webflow || [];
Webflow.push(function () {
  gsap.set("[data-gsap]", { autoAlpha: 1 });
  const anpElements = [
    "anp1",
    "anp2",
    "anp4",
    "anp5",
    "anp7",
    "anp15",
    "anp22",
    "anp23",
    "txt.1",
    "txt.2",
    "txt.3",
    "txt.4",
    "txt.5",
    "txt.6",
    "txt.8",
    "txt.9",
    "txt.10",
    "txt.14",
    "txt.15",
    "txt.16",
    "txt.17",
    "txt.18",
    "txt.19",
    "txt.20",
    "txt.21",
    "txt.22",
    "txt.23",
  ];
  const existingpSelectors = anpElements
    .filter((anp) => document.querySelector(`[data-gsap="${anp}"]`))
    .map((anp) => `[data-gsap="${anp}"]`)
    .join(", ");
  if (existingpSelectors) {
    let typeSplit = new SplitType(existingpSelectors, {
      types: "words, chars",
      tagName: "span",
    });
  }

  function createScrollTrigger(triggerElement, timeline) {
    ScrollTrigger.create({
      trigger: triggerElement,
      start: "top 70%",
      toggleActions: "play none none reverse",
      animation: timeline,
    });
  }

  const defaultSettings = {
    opacity: 1,
    ease: "back.out(1)",
    duration: 1, // Set default duration to 1 second
  };

  const textAnimations = [
  {
    id: "txt.1",
    target: ".char",
    from: { y: -20, opacity: 0 },
    to: { y: 0, stagger: 0.03 },
  },
  {
    id: "txt.14",
    target: ".word",
    from: { y: -30, opacity: 0 },
    to: { y: 0, stagger: 0.1 },
  },
  {
    id: "anp1",
    target: ".char",
    from: { y: -20, opacity: 0 },
    to: { y: 0, stagger: 0.03 },
  },
  {
    id: "txt.2",
    target: ".char",
    from: { y: 20, opacity: 0 },
    to: { y: 0, stagger: 0.02 },
  },
  {
    id: "txt.3",
    target: ".char",
    from: { x: -20, opacity: 0 },
    to: { x: 0, stagger: 0.03, ease: "power4.inOut" },
    additionalAnimation: {
      target: "self",
      from: { x: -20 },
      to: { x: 0, ease: "power4.inOut" },
      position: "<",
    },
  },
  {
    id: "txt.4",
    target: ".char",
    from: { x: -30, skewX: 20, opacity: 0 },
    to: { x: 0, skewX: 0, stagger: 0.03, ease: "back.out(2)" },
    additionalAnimation: {
      target: "self",
      from: { x: -20 },
      to: { x: 0 },
      position: "<",
    },
  },
  {
    id: "txt.5",
    target: ".word",
    from: { x: -50, opacity: 0, skewX: 20 },
    to: {
      x: 0,
      skewX: 0,
      stagger: 0.1,
      duration: 0.75,
      ease: "back.inOut(2)",
    },
  },
  {
    id: "txt.6",
    target: ".word",
    from: { x: 50, opacity: 0, skewX: -20 },
    to: {
      x: 0,
      skewX: 0,
      stagger: 0.1,
      duration: 0.75,
      ease: "back.inOut(2)",
    },
  },
  {
    id: "txt.7",
    target: "self",
    from: { y: 30, scale: 0.5, filter: "blur(100px)", opacity: 0 },
    to: {
      y: 0,
      scale: 1,
      filter: "blur(0px)",
      duration: 1,
      ease: "power3.Out",
    },
  },
  {
    id: "anp2",
    target: "self",
    from: { y: 30, scale: 0.5, filter: "blur(100px)", opacity: 0 },
    to: {
      y: 0,
      scale: 1,
      filter: "blur(0px)",
      duration: 1,
      ease: "power3.Out",
    },
  },
  {
    id: "txt.8",
    target: ".char",
    from: { scale: 0 },
    to: { scale: 1, ease: "power2.out", duration: 1.5 },
    additionalAnimation: {
      target: "self",
      from: { letterSpacing: "0.5em", filter: "blur(40px)" },
      to: {
        letterSpacing: "0em",
        filter: "blur(0px)",
        duration: 1.5,
        ease: "power2.out",
      },
      position: "<",
    },
  },
  {
    id: "txt.15",
    target: ".char",
    from: { scale: 3, opacity: 0, x: 50 },
    to: { scale: 1, stagger: 0.02, x: 0, ease: "power2.out", duration: 0.5 },
  },
  {
    id: "txt.16",
    target: ".char",
    from: { scale: 2, opacity: 0 },
    to: { scale: 1, stagger: 0.02, ease: "power2.out", duration: 0.75 },
    additionalAnimation: {
      target: "self",
      from: { letterSpacing: "0.1em" },
      to: { letterSpacing: "0em", duration: 0.75 },
      position: "0.75",
    },
  },
  {
    id: "txt.21",
    target: ".word",
    from: { scale: 3, opacity: 0, y: 20 },
    to: { scale: 1, stagger: 0.05, y: 0, ease: "power2.out", duration: 0.5 },
    additionalAnimation: {
      target: "self",
      from: { letterSpacing: "0.1em" },
      to: { letterSpacing: "0em", duration: 0.75, ease: "back.out(2)" },
    },
  },
  {
    id: "txt.22",
    target: ".word",
    from: { y: 50, opacity: 0, },
    to: {
      y: 0,
      stagger: 0.05,
      duration: 0.75,
      ease: "expo.inOut"
    },
  },
  {
    id: "txt.23",
    target: ".word",
    from: { y: 50, opacity: 0, },
    to: {
      y: 0,
      stagger: 0.05,
      duration: 0.75,
    },
  }, ];

  function getDuration(element, defaultDuration = 1) {
    const customDuration = element.getAttribute("gfluo-duration");
    return customDuration ? parseFloat(customDuration) : defaultDuration;
  }

  const applyTextAnimation = (config) => {
    const elements = document.querySelectorAll(`[data-gsap="${config.id}"]`);
    elements.forEach((element) => {
      gsap.set(element, { opacity: 1 });

      const targets =
        config.target === "self" ?
        element :
        element.querySelectorAll(config.target);

      const tl = gsap.timeline({
        paused: true,
        defaults: defaultSettings,
      });

      const duration = getDuration(
        element,
        config.to.duration || defaultSettings.duration
      );

      tl.fromTo(
        targets, { ...config.from }, { ...defaultSettings, ...config.to, duration }
      );

      if (config.additionalAnimation) {
        const additionalTarget =
          config.additionalAnimation.target === "self" ?
          element :
          element.querySelectorAll(config.additionalAnimation.target);

        const additionalDuration = getDuration(
          element,
          config.additionalAnimation.to.duration || defaultSettings.duration
        );

        tl.fromTo(
          additionalTarget,
          config.additionalAnimation.from,
          {
            ...defaultSettings,
            ...config.additionalAnimation.to,
            duration: additionalDuration,
          },
          config.additionalAnimation.position
        );
      }

      createScrollTrigger(element, tl);
    });
  };

  function setupAnimationTxt17(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.set(elements, { opacity: options.initialOpacity ?? 1 });

    elements.forEach((element) => {
      const tl = gsap.timeline({ paused: true });

      const chars = element.querySelectorAll(".char");
      const duration = getDuration(element, options.duration ?? 0.4);

      tl.from(chars, {
        rotationX: options.rotationX ?? -180,
        duration: duration,
        stagger: options.stagger ?? 0.05,
        opacity: options.initialCharOpacity ?? 0,
        scale: options.initialScale ?? 0.8,
        ease: options.ease ?? "power2.Out",
      });

      ScrollTrigger.create({
        trigger: element,
        start: options.triggerStart ?? "top 80%",
        end: options.triggerEnd ?? "bottom 20%",
        toggleActions: options.toggleActions ?? "play none none reverse",
        onEnter: () => tl.play(),
        onLeaveBack: () => tl.reverse(),
        markers: options.markers ?? false,
      });
    });
  }

  setupAnimationTxt17('[data-gsap="txt.17"]');

  function setupAnimationTxt18(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.set(elements, { opacity: options.initialOpacity ?? 1 });

    elements.forEach((element) => {
      const tl = gsap.timeline({ paused: true });

      const words = element.querySelectorAll(".word");
      const duration = getDuration(element, options.duration ?? 1);

      tl.fromTo(
        words,
        {
          rotationY: options.initialRotationY ?? -180,
          opacity: options.initialWordOpacity ?? 0,
        },
        {
          rotationY: options.finalRotationY ?? 0,
          opacity: options.finalWordOpacity ?? 1,
          stagger: options.stagger ?? 0.1,
          duration: duration,
          ease: options.ease ?? "back.out",
        }
      );

      ScrollTrigger.create({
        trigger: element,
        start: options.triggerStart ?? "top bottom",
        end: options.triggerEnd ?? "bottom top",
        toggleActions: options.toggleActions ?? "play none none reverse",
        onEnter: () => tl.play(),
        onLeaveBack: () => tl.reverse(),
        markers: options.markers ?? false,
      });
    });
  }

  setupAnimationTxt18('[data-gsap="txt.18"]');

  function setupAnimationTxt19(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.set(elements, { opacity: options.containerOpacity ?? 1 });

    elements.forEach((element) => {
      const tl = gsap.timeline({ paused: true });
      const duration = getDuration(element, options.duration ?? 0.5);

      tl.from(element.children, {
        y: () => gsap.utils.random(options.minY ?? -100, options.maxY ?? 100),
        x: options.animateX ?
          () => gsap.utils.random(options.minX ?? -100, options.maxX ?? 100) : 0,
        opacity: options.initialOpacity ?? 0,
        stagger: options.stagger ?? 0.03,
        duration: duration,
        ease: options.ease ?? "back.out(2)",
      });

      ScrollTrigger.create({
        trigger: element,
        start: options.triggerStart ?? "top 80%",
        end: options.triggerEnd ?? "bottom 20%",
        toggleActions: options.toggleActions ?? "play none none reverse",
        onEnter: () => tl.play(),
        onLeaveBack: () => tl.reverse(),
        markers: options.markers ?? false,
      });
    });
  }

  setupAnimationTxt19('[data-gsap="txt.19"]');

  function setupAnimationTxt20(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.set(elements, { opacity: options.initialOpacity ?? 1 });

    elements.forEach((element) => {
      const tl = gsap.timeline({ paused: true });

      const chars = element.querySelectorAll(".word");
      const duration = getDuration(element, options.duration ?? 0.75);

      tl.from(chars, {
        rotationX: options.rotationX ?? -180,
        duration: duration,
        stagger: options.stagger ?? 0.075,
        opacity: options.initialCharOpacity ?? 0,
        scale: options.initialScale ?? 0.8,
        ease: options.ease ?? "power1.inOut",
      });

      ScrollTrigger.create({
        trigger: element,
        start: options.triggerStart ?? "top 80%",
        end: options.triggerEnd ?? "bottom 20%",
        toggleActions: options.toggleActions ?? "play none none reverse",
        onEnter: () => tl.play(),
        onLeaveBack: () => tl.reverse(),
        markers: options.markers ?? false,
      });
    });
  }

  setupAnimationTxt20('[data-gsap="txt.20"]');

  //set 3
  function setupAnimations9(selector, options = {}) {
    const elements = document.querySelectorAll(selector);
    if (elements.length === 0) return;

    elements.forEach((element) => {
      const chars = element.querySelectorAll(".char");

      gsap.set(chars, { opacity: 1 });
      gsap.set(element, { opacity: 1 });

      const handleMouseMove = (e) => {
        const { clientX: mouseX, clientY: mouseY } = e;
        chars.forEach((char) => {
          const rect = char.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const distanceX = mouseX - centerX;
          const distanceY = mouseY - centerY;

          const duration = getDuration(element, 0.3);
          gsap.to(char, {
            x: gsap.utils.clamp(-20, 20, distanceX / 10),
            y: gsap.utils.clamp(-20, 20, distanceY / 10),
            duration: duration,
            ease: "power2.out",
          });
        });
      };

      document.addEventListener("mousemove", handleMouseMove);
    });
  }

  setupAnimations9("[data-gsap='anp4']");
  setupAnimations9("[data-gsap='txt.9']", {
    handleSpaces: true,
    duration: 1.5,
  });

  function setupAnimation11(selector, options = {}) {
    const counterElems = document.querySelectorAll(selector);

    if (counterElems.length === 0) {
      return;
    }

    counterElems.forEach((counterElem) => {
      gsap.set(counterElem, { opacity: 1 });
      const targetValue = parseInt(counterElem.innerText) || 0;

      const originalText = counterElem.innerText;

      counterElem.innerText = "0";

      const duration = getDuration(counterElem, options.duration || 2);

      gsap.to(counterElem, {
        scrollTrigger: {
          trigger: counterElem,
          start: "top 80%",
          toggleActions: "restart none none reverse",
        },
        innerText: targetValue,
        duration: duration,
        snap: { innerText: 1 },
        ease: "power2.out",
        onComplete: () => {
          counterElem.innerText = originalText;
        },
      });
    });
  }

  setupAnimation11('[data-gsap="anp8"]');
  setupAnimation11('[data-gsap="txt.11"]', { duration: 3 });

  function setupAnimation12(selector, options = {}) {
    const elements = document.querySelectorAll(selector);
    if (elements.length === 0) {
      return;
    }

    elements.forEach((element) => {
      const originalText = element.textContent.trim();
      const words = originalText.split(",").map((word) => word.trim());
      gsap.set(element, { opacity: 1 });
      if (words.length < 2) {
        console.log(
          "Add more words divided by `,`. Element doesn't have enough words to animate:",
          element
        );
        return;
      }
      let currentIndex = 0;
      const wrapper = document.createElement("span");
      const changingWord = document.createElement("span");
      wrapper.appendChild(changingWord);
      element.textContent = "";
      element.appendChild(wrapper);
      changingWord.textContent = words[0];

      function rotateWords() {
        const fadeDuration = getDuration(element, options.fadeDuration || 0.5);
        gsap.to(changingWord, {
          duration: fadeDuration,
          opacity: 0,
          y: options.yOffset || 20,
          onComplete: () => {
            currentIndex = (currentIndex + 1) % words.length;
            changingWord.textContent = words[currentIndex];
            gsap.to(changingWord, {
              duration: fadeDuration,
              opacity: 1,
              y: 0,
            });
          },
        });
      }
      setInterval(rotateWords, options.rotationInterval || 2000);
    });
  }
  setupAnimation12('[data-gsap="anp9"]');
  setupAnimation12('[data-gsap="txt.12"]');

  function setupAnimation13(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    elements.forEach((element) => {
      gsap.set(element, { opacity: 1 });
      const originalText = element.textContent;
      const glitchChars = options.glitchChars || "!<>-_\\/[]{}—=+*^?#________";

      function glitchText() {
        let newText = "";
        for (let i = 0; i < originalText.length; i++) {
          newText +=
            Math.random() < (options.glitchProbability || 0.1) ?
            glitchChars[Math.floor(Math.random() * glitchChars.length)] :
            originalText[i];
        }
        element.textContent = newText;
      }

      function animateOpacity() {

        return gsap.to(element, {
          duration: 0.05,
          opacity: options.minOpacity || 0.5,
          yoyo: true,
          repeat: -1,
          ease: "power1.inOut",
        });
      }

      function animateSkew() {

        return gsap.to(element, {
          duration: 0.05,
          skewX: options.skewAngle || 10,
          yoyo: true,
          repeat: -1,
          ease: "power1.inOut",
        });
      }

      let glitchInterval;
      let opacityAnimation;
      let skewAnimation;

      function startGlitch() {
        glitchInterval = setInterval(glitchText, options.glitchInterval || 100);
        opacityAnimation = animateOpacity();
        skewAnimation = animateSkew();
      }

      function stopGlitch() {
        clearInterval(glitchInterval);
        if (opacityAnimation) opacityAnimation.kill();
        if (skewAnimation) skewAnimation.kill();
        gsap.to(element, { opacity: 1, skewX: 0, duration: 0.1 });
        element.textContent = originalText;
      }

      if (options.intermittent) {
        function glitchCycle() {
          const glitchDuration = gsap.utils.random(
            options.minGlitchDuration || 0.5,
            options.maxGlitchDuration || 1.5
          );
          const normalDuration = gsap.utils.random(
            options.minNormalDuration || 2,
            options.maxNormalDuration || 5
          );

          startGlitch();
          gsap.delayedCall(glitchDuration, () => {
            stopGlitch();
            gsap.delayedCall(normalDuration, glitchCycle);
          });
        }

        glitchCycle();
      } else {
        startGlitch();
      }
    });
  }

  setupAnimation13('[data-gsap="anp12"]', {
    intermittent: true,
    glitchChars: "!<>-_\\/[]{}—=+*^?#¿∆¤0________",
    glitchInterval: 100,
    minGlitchDuration: 0.5,
    maxGlitchDuration: 1.5,
    minNormalDuration: 2,
    maxNormalDuration: 5,
  });

  setupAnimation13('[data-gsap="txt.13"]', {
    intermittent: true,
    glitchChars: "!<>-_\\/[]{}—=+*^?#¿∆¤0________",
    glitchInterval: 100,
    minGlitchDuration: 0.5,
    maxGlitchDuration: 1.5,
    minNormalDuration: 2,
    maxNormalDuration: 5,
  });

  function setupAnimation10(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    elements.forEach((element) => {
      gsap.set(element, { opacity: 1 });

      const text = element.textContent;
      element.textContent = "";

      const textElement = document.createElement("span");
      textElement.className = "typed-text";
      element.appendChild(textElement);

      const cursor = document.createElement("span");
      cursor.className = "cursor";
      cursor.textContent = "|";
      element.appendChild(cursor);

      let typewriterTimeline;

      function typeWriter(text, i = 0) {
        if (i < text.length) {
          textElement.innerHTML += text.charAt(i);
          i++;
          const typingSpeed = getDuration(element, options.typingSpeed || 0.07);
          typewriterTimeline = gsap.delayedCall(typingSpeed, () =>
            typeWriter(text, i)
          );
        }
      }

      const cursorAnimation = gsap.to(cursor, {
        opacity: 0,
        repeat: -1,
        yoyo: true,
        duration: 0.6,
        ease: "expo.inOut",
        paused: false,
      });

      ScrollTrigger.create({
        trigger: element,
        start: options.triggerStart || "top 90%",
        end: options.triggerEnd || "bottom 0%",
        onEnter: () => {
          textElement.innerHTML = "";
          typeWriter(text);
          cursorAnimation.play();
        },
        onEnterBack: () => {
          textElement.innerHTML = "";
          typeWriter(text);
          cursorAnimation.play();
        },
        onLeave: () => {
          if (typewriterTimeline) typewriterTimeline.kill();
          textElement.innerHTML = "";
          cursorAnimation.play();
        },
        onLeaveBack: () => {
          if (typewriterTimeline) typewriterTimeline.kill();
          textElement.innerHTML = "";
          cursorAnimation.play();
        },
      });
    });
  }
  setupAnimation10('[data-gsap="anp13"]');
  setupAnimation10('[data-gsap="txt.10"]');

  function setupAnimationEl2(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.registerPlugin(Draggable);

    elements.forEach((element) => {
      gsap.set(element, { opacity: 1 });

      Draggable.create(element, {
        onPress: () => {
          gsap.to(element, {
            scale: options.pressScale || 1.1,
            duration: options.scaleDuration || 0.1,
          });
        },
        onRelease: () => {
          gsap.to(element, {
            scale: 1,
            duration: options.scaleDuration || 0.1,
          });
        },
        ...options.draggableOptions,
      });
    });
  }

  setupAnimationEl2('[data-gsap="el.2"]');
  setupAnimationEl2('[data-gsap="anp5"]');

  function getElementDuration(element, defaultDuration) {
    const customDuration = element.getAttribute("gfluo-duration");
    return customDuration ? parseFloat(customDuration) : defaultDuration;
  }

  function setupAnimationEl3(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    elements.forEach((element) => {
      gsap.set(element, { opacity: 1 });

      element.addEventListener("mouseenter", enterElement);
      element.addEventListener("mouseleave", leaveElement);
      element.addEventListener("mousemove", moveElement);

      function enterElement(e) {
        const duration = getElementDuration(
          e.currentTarget,
          options.enterDuration || 0.3
        );
        gsap.to(e.currentTarget, {
          scale: options.enterScale || 1.1,
          duration: duration,
          ease: options.enterEase || "power2.out",
        });
      }

      function leaveElement(e) {
        const duration = getElementDuration(
          e.currentTarget,
          options.leaveDuration || 0.3
        );
        gsap.to(e.currentTarget, {
          scale: 1,
          x: 0,
          y: 0,
          duration: duration,
          ease: options.leaveEase || "power2.out",
        });
      }

      function moveElement(e) {
        const rect = e.currentTarget.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const moveX = (e.clientX - centerX) / (options.moveDivisor || 10);
        const moveY = (e.clientY - centerY) / (options.moveDivisor || 10);

        const duration = getElementDuration(
          e.currentTarget,
          options.moveDuration || 0.3
        );
        gsap.to(e.currentTarget, {
          x: moveX,
          y: moveY,
          duration: duration,
          ease: options.moveEase || "power2.out",
        });
      }
    });
  }

  setupAnimationEl3('[data-gsap="anp10"]', {
    enterScale: 1.1,
    enterDuration: 0.5,
    leaveDuration: 0.5,
  });

  setupAnimationEl3('[data-gsap="el.3"]', {
    enterScale: 1.1,
    enterDuration: 0.5,
    leaveDuration: 0.5,
  });
  setupAnimationEl3('[data-gsap="btn.6"]', {
    enterScale: 1.1,
    enterDuration: 0.5,
    leaveDuration: 0.5,
  });

  function setupAnimationEl4(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.set(elements, { opacity: 0 });

    elements.forEach((element) => {
      const duration = getElementDuration(element, options.duration ?? 0.75);

      gsap.fromTo(
        element,
        {
          opacity: 0,
          x: options.startX ?? -100,
          y: options.startY ?? 0,
        },
        {
          opacity: 1,
          x: options.endX ?? 0,
          y: options.endY ?? 0,
          duration: duration,
          ease: options.ease ?? "back.inOut(2)",
          scrollTrigger: options.useScrollTrigger ?
          {
            trigger: element,
            start: options.triggerStart ?? "top 80%",
            toggleActions: options.toggleActions ?? "play none none none",
          } : null,
        }
      );
    });
  }

  setupAnimationEl4('[data-gsap="el.4"]', {
    useScrollTrigger: true,
    triggerStart: "top 70%",
    toggleActions: "play none none reverse"
  });

  function setupAnimationEl5(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.set(elements, { opacity: options.initialOpacity ?? 1 });

    elements.forEach((element) => {
      const duration = getElementDuration(element, options.duration ?? 0.5);

      const tl = gsap.timeline({ paused: true });

      tl.from(element, {
        scale: options.initialScale ?? 0,
        opacity: options.initialElementOpacity ?? 0,
        duration: duration,
        ease: options.ease ?? "power1.inOut",
      });

      ScrollTrigger.create({
        trigger: element,
        start: options.triggerStart ?? "top bottom-=100",
        end: options.triggerEnd ?? "bottom top+=100",
        onEnter: () => tl.play(),
        scrub: options.scrub ?? true,
        markers: options.markers ?? false,
        toggleActions: options.toggleActions ?? "play none none reverse",
      });
    });
  }

  setupAnimationEl5('[data-gsap="el.5"]');

  function setupAnimationImg1(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    elements.forEach((element) => {
      gsap.set(element, { opacity: 1 });

      const duration = getElementDuration(element, options.duration || 1.5);

      const animation = gsap.from(element, {
        clipPath: options.clipPath || "inset(50% 50% 50% 50%)",
        duration: duration,
        opacity: options.fadeFrom !== undefined ? options.fadeFrom : 1,
        ease: options.ease || "power4.inOut",
        paused: true,
      });

      ScrollTrigger.create({
        trigger: element,
        start: options.triggerStart || "top 80%",
        end: options.triggerEnd || "bottom 20%",
        toggleActions: options.toggleActions || "play none none reverse",
        onEnter: () => animation.play(),
        onLeaveBack: () => animation.reverse(),
        markers: options.markers || false,
      });
    });
  }

  function setupAnimationEl6(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.set(elements, { opacity: 0 });

    elements.forEach((element) => {
      const duration = getElementDuration(element, options.duration ?? 0.75);

      gsap.fromTo(
        element,
        {
          opacity: 0,
          x: options.startX ?? 0,
          y: options.startY ?? 100,
        },
        {
          opacity: 1,
          x: options.endX ?? 0,
          y: options.endY ?? 0,
          duration: duration,
          ease: options.ease ?? "back.inOut(2)",
          scrollTrigger: options.useScrollTrigger ?
          {
            trigger: element.parentElement || element,
            start: options.triggerStart ?? "top 80%",
            toggleActions: options.toggleActions ?? "play none none none",
          } : null,
        }
      );
    });
  }

  setupAnimationEl6('[data-gsap="el.6"]', {
    useScrollTrigger: true,
    triggerStart: "top 70%",
    toggleActions: "play none none reverse",
  });

  function setupAnimationEl7(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.set(elements, { opacity: 0 });

    elements.forEach((element) => {
      const duration = getElementDuration(element, options.duration ?? 0.75);

      gsap.fromTo(
        element,
        {
          opacity: 0,
          x: options.startX ?? 100,
          y: options.startY ?? 0,
        },
        {
          opacity: 1,
          x: options.endX ?? 0,
          y: options.endY ?? 0,
          duration: duration,
          ease: options.ease ?? "back.inOut(2)",
          scrollTrigger: options.useScrollTrigger ?
          {
            trigger: element,
            start: options.triggerStart ?? "top 80%",
            toggleActions: options.toggleActions ?? "play none none none",
          } : null,
        }
      );
    });
  }

  setupAnimationEl7('[data-gsap="el.7"]', {
    useScrollTrigger: true,
    triggerStart: "top 70%",
    toggleActions: "play none none reverse",
  });

  function setupAnimationImg1(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    elements.forEach((element) => {
      gsap.set(element, { opacity: 1 });

      const duration = getElementDuration(element, options.duration || 1.5);

      const animation = gsap.from(element, {
        clipPath: options.clipPath || "inset(50% 50% 50% 50%)",
        duration: duration,
        opacity: options.fadeFrom !== undefined ? options.fadeFrom : 1,
        ease: options.ease || "power4.inOut",
        paused: true,
      });

      ScrollTrigger.create({
        trigger: element,
        start: options.triggerStart || "top 80%",
        end: options.triggerEnd || "bottom 20%",
        toggleActions: options.toggleActions || "play none none reverse",
        onEnter: () => animation.play(),
        onLeaveBack: () => animation.reverse(),
        markers: options.markers || false,
      });
    });
  }

  setupAnimationImg1('[data-gsap="anp6"]', {
    fadeFrom: 0,
  });
  setupAnimationImg1('[data-gsap="img.1"]', {
    fadeFrom: 0,
  });

  function setupAnimationImg2(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    elements.forEach((element) => {
      gsap.set(element, { opacity: 1 });

      const duration = getElementDuration(element, options.duration || 1);

      gsap.from(element, {
        borderRadius: options.initialBorderRadius || "100rem",
        opacity: options.initialOpacity || 0.1,
        scale: options.initialScale || 0.5,
        duration: duration,
        ease: options.ease || "power1.out",
        scrollTrigger: {
          trigger: element,
          start: options.triggerStart || "top 80%",
          end: options.triggerEnd || "bottom 20%",
          scrub: options.scrub !== undefined ? options.scrub : true,
          markers: options.markers || false,
          toggleActions: options.toggleActions || "play none none reverse",
        },
      });
    });
  }

  setupAnimationImg2('[data-gsap="img.2"]');

  function setupAnimationImg3(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.set(elements, { opacity: options.initialOpacity ?? 1 });

    elements.forEach((element) => {
      const duration = getElementDuration(element, options.duration ?? 1);

      gsap.fromTo(
        element,
        {
          clipPath: options.initialClipPath ?? "inset(100% 0% 0% 0%)",
        },
        {
          clipPath: options.finalClipPath ?? "inset(0% 0% 0% 0%)",
          duration: duration,
          ease: options.ease ?? "ease",
          scrollTrigger: {
            trigger: element,
            start: options.triggerStart || "top 80%",
            end: options.triggerEnd || "bottom 20%",
            scrub: options.scrub ?? true,
            markers: options.markers ?? false,
            toggleActions: options.toggleActions ?? "play none none reverse",
          },
        }
      );
    });
  }

  setupAnimationImg3('[data-gsap="img.3"]');

  function setupAnimationImg4(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.set(elements, { opacity: options.initialOpacity ?? 1 });

    elements.forEach((element) => {
      const duration = getElementDuration(element, options.duration ?? 1);

      gsap.fromTo(
        element,
        {
          clipPath: options.initialClipPath ?? "inset(0% 50% 0% 50%)",
        },
        {
          clipPath: options.finalClipPath ?? "inset(0% 0% 0% 0%)",
          duration: duration,
          ease: options.ease ?? "ease",
          scrollTrigger: {
            trigger: element,
            start: options.triggerStart || "top 80%",
            end: options.triggerEnd || "bottom 20%",
            scrub: options.scrub ?? true,
            markers: options.markers ?? false,
            toggleActions: options.toggleActions ?? "play none none reverse",
          },
        }
      );
    });
  }

  setupAnimationImg4('[data-gsap="img.4"]');

  function setupAnimationImg5(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.set(elements, { opacity: options.initialOpacity ?? 1 });

    elements.forEach((element) => {
      const duration = getElementDuration(element, options.duration ?? 1);

      gsap.fromTo(
        element,
        {
          clipPath: options.initialClipPath ?? "inset(0% 100% 0% 0%)",
        },
        {
          clipPath: options.finalClipPath ?? "inset(0% 0% 0% 0%)",
          duration: duration,
          ease: options.ease ?? "ease",
          scrollTrigger: {
            trigger: element,
            start: options.triggerStart || "top 80%",
            end: options.triggerEnd || "bottom 20%",
            scrub: options.scrub ?? true,
            markers: options.markers ?? false,
            toggleActions: options.toggleActions ?? "play none none reverse",
          },
        }
      );
    });
  }

  setupAnimationImg5('[data-gsap="img.5"]');

  function setupAnimationImg6(selector, options = {}) {
    const elements = document.querySelectorAll(selector);

    if (elements.length === 0) {
      return;
    }

    gsap.set(elements, { opacity: options.initialOpacity ?? 1 });

    elements.forEach((element) => {
      const duration = getElementDuration(element, options.duration ?? 1);

      gsap.fromTo(
        element,
        {
          clipPath: options.initialClipPath ?? "inset(0% 0% 0% 100%)",
        },
        {
          clipPath: options.finalClipPath ?? "inset(0% 0% 0% 0%)",
          duration: duration,
          ease: options.ease ?? "ease",
          scrollTrigger: {
            trigger: element,
            start: options.triggerStart || "top 80%",
            end: options.triggerEnd || "bottom 20%",
            scrub: options.scrub ?? true,
            markers: options.markers ?? false,
            toggleActions: options.toggleActions ?? "play none none reverse",
          },
        }
      );
    });
  }

  setupAnimationImg6('[data-gsap="img.6"]');

  function getElementDuration(element, defaultDuration) {
    const customDuration = element.getAttribute("gfluo-duration");
    return customDuration ? parseFloat(customDuration) : defaultDuration;
  }

  const TextAnimationSystem = {
    splitTextInstances: {},

    animations: [
      (targets, duration) =>
      gsap.fromTo(
        targets, { opacity: 0 },
        {
          opacity: 1,
          duration: duration,
          stagger: 0.15,
          ease: "power2.in",
        }
      ),
      (targets, duration) =>
      gsap.fromTo(
        targets, { opacity: 0, y: 50 },
        {
          opacity: 1,
          y: 0,
          duration: duration,
          stagger: 0.15,
          ease: "back.out(0.75)",
        }
      ),
      (targets, duration) =>
      gsap.fromTo(
        targets, { opacity: 0, x: -20 },
        {
          opacity: 1,
          x: 0,
          duration: duration,
          stagger: 0.15,
          ease: "circ.out",
        }
      ),
      (targets, duration) =>
      gsap.to(targets, {
        opacity: 0,
        filter: "blur(10px)",
        duration: duration,
        stagger: 0.05,
        ease: "power2.in",
      }),
      (targets, duration) =>
      gsap.fromTo(
        targets, { opacity: 0, filter: "blur(10px)" },
        {
          opacity: 1,
          filter: "blur(0px)",
          duration: duration,
          stagger: 0.15,
          ease: "circ.out",
        }
      ),
      (targets, duration) =>
      gsap.fromTo(
        targets, { opacity: 0, scaleY: 0, y: 20 },
        {
          opacity: 1,
          scaleY: 1,
          y: 0,
          duration: duration,
          stagger: 0.15,
          ease: "circ.out",
        }
      ),
      (targets, duration) =>
      gsap.fromTo(
        targets, { y: 20, filter: "blur(15px)" },
        {
          y: 0,
          filter: "blur(0px)",
          duration: duration,
          stagger: 0.15,
        }
      ),
      (targets, duration) =>
      gsap.fromTo(
        targets, { opacity: 0, filter: "blur(10px)", y: -30 },
        {
          opacity: 1,
          y: 0,
          filter: "blur(0px)",
          duration: duration,
          stagger: 0.15,
          ease: "circ.out",
        }
      ),
      (targets, duration) =>
      gsap.fromTo(
        targets, { opacity: 0, x: 50 },
        {
          opacity: 1,
          x: 0,
          duration: duration,
          stagger: 0.15,
          ease: "circ.out",
        }
      ),
    ],

    init() {
      if (this.hasElements()) {
        this.setInitialOpacity();
        this.initializeSplitType();
        this.setupScrollTriggers();
        window.addEventListener("resize", this.handleResize.bind(this));
      } else {
        return;
      }
    },

    hasElements() {
      return document.querySelectorAll('[data-gsap^="par."]').length > 0;
    },

    initializeSplitType() {
      const elements = document.querySelectorAll('[data-gsap^="par."]');
      elements.forEach((element) => {
        const dataGsap = element.getAttribute("data-gsap");
        this.splitTextInstances[dataGsap] = new SplitType(element, {
          types: "lines",
        });
      });
    },

    setupScrollTriggers() {
      const elements = document.querySelectorAll('[data-gsap^="par."]');
      elements.forEach((element, index) => {
        const parNumber = parseInt(
          element.getAttribute("data-gsap").split(".")[1]
        );
        const animationIndex = (parNumber - 1) % this.animations.length;
        const animation = this.animations[animationIndex];

        const duration = getElementDuration(element, 1); // Default duration of 1 second

        ScrollTrigger.create({
          trigger: element,
          start: "top bottom-=100",
          onEnter: () => {
            gsap.set(element, { opacity: 1 });
            animation(element.querySelectorAll(".line"), duration);
          },
          once: true,
        });
      });
    },

    setInitialOpacity() {
      gsap.set('[data-gsap^="par."]', { opacity: 0 });
    },

    handleResize() {
      if (this.hasElements()) {
        Object.values(this.splitTextInstances).forEach((instance) =>
          instance.revert()
        );
        this.setInitialOpacity();
        this.initializeSplitType();
        this.setupScrollTriggers();
      }
    },

    resetAnimations() {
      if (this.hasElements()) {
        gsap.set('[data-gsap^="par."]', { opacity: 0 });
        gsap.set('[data-gsap^="par."] .line', {
          opacity: 1,
          x: 0,
          y: 0,
          filter: "blur(0px)",
          scale: 1,
        });
      }
    },
  };

  TextAnimationSystem.init();

  function getButtonDuration(button, defaultDuration) {
    const customDuration = button.getAttribute("gfluo-duration");
    return customDuration ? parseFloat(customDuration) : defaultDuration;
  }

  const buttonAnimations = [
  {
    id: "btn.1",
    init: (button) => {
      gsap.set(button, {
        opacity: 1,
        overflow: "hidden",
        position: "relative",
      });
      const clipEl = document.createElement("div");
      clipEl.setAttribute("aria-hidden", "true");
      Object.assign(clipEl.style, {
        position: "absolute",
        backgroundColor: "#00000030",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        display: "none",
      });
      button.appendChild(clipEl);

      const getPercentage = (value, total) => (value / total) * 100;

      button.addEventListener("mouseenter", (e) => {
        const rect = button.getBoundingClientRect();
        const percentTop = getPercentage(e.clientY - rect.top, rect.height);
        const percentLeft = getPercentage(e.clientX - rect.left, rect.width);

        gsap.set(clipEl, { display: "flex" });
        const duration = getButtonDuration(button, 0.3);
        gsap.fromTo(
          clipEl, { clipPath: `circle(0% at ${percentLeft}% ${percentTop}%)` },
          {
            clipPath: `circle(141.4% at ${percentLeft}% ${percentTop}%)`,
            duration: duration,
            ease: "power1.in",
          }
        );
      });

      button.addEventListener("mouseleave", (e) => {
        const rect = button.getBoundingClientRect();
        const percentTop = getPercentage(e.clientY - rect.top, rect.height);
        const percentLeft = getPercentage(e.clientX - rect.left, rect.width);

        const duration = getButtonDuration(button, 0.3);
        gsap.to(clipEl, {
          clipPath: `circle(0% at ${percentLeft}% ${percentTop}%)`,
          overwrite: true,
          duration: duration,
          ease: "power1.out",
        });
      });
    },
  },
  {
    id: "btn.2",
    init: (button) => {
      gsap.set(button, { opacity: 1 });
      const duration = getButtonDuration(button, 0.2);

      button.addEventListener("mouseenter", () => {
        const buttonColor = window.getComputedStyle(button).backgroundColor;
        gsap.to(button, {
          scale: 1.1,
          boxShadow: `0 0 15px ${buttonColor.replace(")", ", 1)")}`,
          duration: duration,
        });
      });

      button.addEventListener("mousedown", () => {
        gsap.to(button, {
          scale: 0.95,
          duration: 0.05,
        });
      });

      button.addEventListener("mouseup", () => {
        gsap.to(button, {
          scale: 1.1,
          duration: 0.2,
        });
      });

      button.addEventListener("mouseleave", () => {
        gsap.to(button, {
          boxShadow: "none",
          duration: duration,
          scale: 1,
        });
      });
    },
  },
  {
    id: "btn.5",
    init: (button) => {
      gsap.set(button, { opacity: 1 });
      const duration = getButtonDuration(button, 0.3);

      button.addEventListener("mouseenter", () => {
        const computedStyle = window.getComputedStyle(button);
        const initialPaddingLeft = parseFloat(computedStyle.paddingLeft);
        const initialPaddingRight = parseFloat(computedStyle.paddingRight);

        gsap.to(button, {
          paddingLeft: initialPaddingLeft * 1.5,
          paddingRight: initialPaddingRight * 1.5,
          scale: 1.1,
          duration: duration,
          ease: "back.out(4)",
        });
        button.dataset.initialPaddingLeft = initialPaddingLeft;
        button.dataset.initialPaddingRight = initialPaddingRight;
      });

      button.addEventListener("mouseleave", () => {
        const initialPaddingLeft = parseFloat(
          button.dataset.initialPaddingLeft
        );
        const initialPaddingRight = parseFloat(
          button.dataset.initialPaddingRight
        );

        gsap.to(button, {
          paddingLeft: initialPaddingLeft,
          paddingRight: initialPaddingRight,
          scale: 1,
          duration: duration,
          ease: "back.out(4)",
        });
      });
    },
  }, ];
  const applyButtonAnimation = (config) => {
    const buttons = document.querySelectorAll(`[data-gsap="${config.id}"]`);
    buttons.forEach((button) => config.init(button));
  };
  const init = () => {
    textAnimations.forEach(applyTextAnimation);
    buttonAnimations.forEach(applyButtonAnimation);
  };
  requestAnimationFrame(init);

  function setupAnimationbtn8(selector, options = {}) {
    const menuItems = document.querySelectorAll(selector);

    if (menuItems.length === 0) {
      return;
    }

    gsap.set(menuItems, { opacity: 1 });

    menuItems.forEach((item) => {
      const textSpan = document.createElement("span");
      textSpan.style.position = "relative";
      textSpan.style.display = "inline-block";
      textSpan.style.color = "inherit";
      textSpan.innerHTML = item.innerHTML;
      item.innerHTML = "";
      item.appendChild(textSpan);

      const underline = document.createElement("div");
      underline.style.position = "absolute";
      underline.style.bottom = options.underlineBottom || "0";
      underline.style.left = "0";
      underline.style.width = "100%";
      underline.style.height = options.underlineHeight || "1px";
      underline.style.backgroundColor =
        options.underlineColor || "currentColor";
      underline.style.transform = "scaleX(0)";
      textSpan.appendChild(underline);

      item.addEventListener("mouseenter", (e) => {
        const itemRect = item.getBoundingClientRect();
        const mouseX = e.clientX;
        const isMouseFromLeft = mouseX < itemRect.left + itemRect.width / 2;

        gsap.set(underline, {
          transformOrigin: isMouseFromLeft ? "left center" : "right center",
        });

        const duration = getButtonDuration(item, options.enterDuration || 0.2);
        gsap.to(underline, {
          scaleX: 1,
          duration: duration,
          ease: options.enterEase || "power2.out",
        });
      });

      item.addEventListener("mouseleave", (e) => {
        const itemRect = item.getBoundingClientRect();
        const mouseX = e.clientX;
        const isMouseToRight = mouseX > itemRect.left + itemRect.width / 2;

        gsap.set(underline, {
          transformOrigin: isMouseToRight ? "right center" : "left center",
        });

        const duration = getButtonDuration(item, options.leaveDuration || 0.2);
        gsap.to(underline, {
          scaleX: 0,
          duration: duration,
          ease: options.leaveEase || "power2.in",
        });
      });
    });
  }

  setupAnimationbtn8('[data-gsap="btn.8"]');
  setupAnimationbtn8('[data-gsap="el.1"]');

  const ButtonEffectsSystem = {
    initSpotlightTrail(button) {
      const canvas = document.createElement("canvas");
      canvas.style.position = "absolute";
      canvas.style.top = "0";
      canvas.style.left = "0";
      canvas.style.pointerEvents = "none";
      button.appendChild(canvas);

      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        canvas.width = button.offsetWidth;
        canvas.height = button.offsetHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      let trail = []; // Changed from const to let
      const maxTrailLength = 10;
      let isAnimating = false;
      let lastX, lastY;

      function drawTrail() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const style = window.getComputedStyle(button);
        const borderRadiusStr = style.borderRadius;

        let [topLeft, topRight, bottomRight, bottomLeft] = borderRadiusStr
          .split(" ")
          .map((v) => parseFloat(v));
        if (isNaN(topRight)) topRight = topLeft;
        if (isNaN(bottomRight)) bottomRight = topLeft;
        if (isNaN(bottomLeft)) bottomLeft = topRight;

        ctx.beginPath();
        ctx.moveTo(topLeft, 0);
        ctx.lineTo(canvas.width - topRight, 0);
        ctx.quadraticCurveTo(canvas.width, 0, canvas.width, topRight);
        ctx.lineTo(canvas.width, canvas.height - bottomRight);
        ctx.quadraticCurveTo(
          canvas.width,
          canvas.height,
          canvas.width - bottomRight,
          canvas.height
        );
        ctx.lineTo(bottomLeft, canvas.height);
        ctx.quadraticCurveTo(0, canvas.height, 0, canvas.height - bottomLeft);
        ctx.lineTo(0, topLeft);
        ctx.quadraticCurveTo(0, 0, topLeft, 0);
        ctx.closePath();
        ctx.clip();

        trail.forEach((point, index) => {
          const size = (maxTrailLength - index) * 3;

          if (isFinite(point.x) && isFinite(point.y) && isFinite(size)) {
            const gradient = ctx.createRadialGradient(
              point.x,
              point.y,
              0,
              point.x,
              point.y,
              size
            );
            gradient.addColorStop(0, `rgba(255, 225, 255, ${point.alpha})`);
            gradient.addColorStop(1, "rgba(255, 225, 255, 0)");

            ctx.beginPath();
            ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
          }

          point.alpha *= 0.92;
        });

        trail = trail.filter(
          (point) =>
          point.alpha >= 0.01 && isFinite(point.x) && isFinite(point.y)
        );

        if (trail.length > 0) {
          requestAnimationFrame(drawTrail);
        } else {
          isAnimating = false;
        }
      }

      function addPoint(x, y) {
        if (isFinite(x) && isFinite(y)) {
          trail.push({ x, y, alpha: 0.5 });
          if (trail.length > maxTrailLength) trail.shift();

          if (!isAnimating) {
            isAnimating = true;
            drawTrail();
          }
        }
      }

      button.addEventListener("mousemove", (e) => {
        const rect = button.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        addPoint(x, y);
        lastX = x;
        lastY = y;
      });

      button.addEventListener("mouseleave", () => {
        let i = 0;
        const exitInterval = setInterval(() => {
          if (i < 5 && isFinite(lastX) && isFinite(lastY)) {
            addPoint(lastX, lastY);
            i++;
          } else {
            clearInterval(exitInterval);
          }
        }, 32);
      });
    },

    initGradualMorph(button) {
      let originalBorderRadius;
      const duration = getButtonDuration(button, 0.3);

      button.addEventListener("mouseenter", () => {
        const style = window.getComputedStyle(button);
        originalBorderRadius = style.borderRadius;

        gsap.killTweensOf(button);
        gsap.to(button, {
          duration: duration,
          borderRadius: originalBorderRadius,
          scale: 1.1,
          ease: "circ.out",
        });
      });

      button.addEventListener("mouseleave", () => {
        gsap.killTweensOf(button);
        gsap.to(button, {
          duration: duration,
          borderRadius: originalBorderRadius,
          scale: 1,
          ease: "circ.out",
        });
      });
    },

    init() {
      const buttons = document.querySelectorAll('[data-gsap="btn.3"]');
      buttons.forEach((button) => {
        this.initSpotlightTrail(button);
        this.initGradualMorph(button);
      });
    },
  };

  ButtonEffectsSystem.init();

  function setupGradualMorphAnimation() {
    const buttons = document.querySelectorAll('[data-gsap="btn.4"]');

    if (buttons.length === 0) {
      return;
    }

    buttons.forEach((button) => {
      gsap.set(button, { opacity: 1, borderRadius: "50px" });
      const duration = getButtonDuration(button, 0.3);

      button.addEventListener("mouseenter", () => {
        gsap.killTweensOf(button);
        gsap.to(button, {
          duration: duration,
          borderRadius: "0px",
          scale: 1.1,
          ease: "circ.out",
        });
      });

      button.addEventListener("mouseleave", () => {
        gsap.killTweensOf(button);
        gsap.to(button, {
          duration: duration,
          borderRadius: "50px",
          scale: 1,
          ease: "circ.out",
        });
      });
    });
  }

  setupGradualMorphAnimation();

  function initMagneticAnimation(button) {
    if (button.childElementCount === 0) {
      const text = button.textContent;
      button.innerHTML = `<span>${text}</span>`;
    }
    const text = button.querySelector("span");
    const duration = getButtonDuration(button, 0.3);

    function magnetize(event) {
      const rect = button.getBoundingClientRect();
      const buttonCenterX = rect.left + rect.width / 2;
      const buttonCenterY = rect.top + rect.height / 2;
      const magneticPullX = (event.clientX - buttonCenterX) * 0.2;
      const magneticPullY = (event.clientY - buttonCenterY) * 0.2;

      gsap.to(text, {
        x: magneticPullX,
        y: magneticPullY,
        duration: duration,
      });
    }

    function resetPosition() {
      gsap.to(text, {
        x: 0,
        y: 0,
        duration: duration,
      });
    }

    button.addEventListener("mousemove", magnetize);
    button.addEventListener("mouseleave", resetPosition);
  }

  document.querySelectorAll('[data-gsap="btn.7"]').forEach((button) => {
    initMagneticAnimation(button);
  });
});

